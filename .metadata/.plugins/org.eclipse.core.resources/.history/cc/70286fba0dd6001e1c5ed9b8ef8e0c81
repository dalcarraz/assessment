package com.cibertec.assessment.service.imp;

import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.cibertec.assessment.beans.PolygonBean;
import com.cibertec.assessment.model.Square;
import com.cibertec.assessment.repo.SquareRepo;
import com.cibertec.assessment.service.PolygonService;
import com.cibertec.assessment.service.SquareService;

@Service
public class SquareServiceImpl implements SquareService {

    @Autowired
    SquareRepo squareRepo;

    @Autowired
    PolygonService polygonService;

    @Override
    public Square create(Square square) {
        return squareRepo.save(square);
    }

    @Override
    public List<Square> list() {
        return squareRepo.findAll();
    }

    @Override
    @Transactional
    public void validateAndCreateSquare(Square square) {
        List<String> intersectedPolygons = findIntersectedPolygons(square);
        square.setPolygons(convertToFormattedArray(intersectedPolygons));
        squareRepo.save(square);
    }

    private List<String> findIntersectedPolygons(Square square) {
        List<String> intersectedPolygonIds = new ArrayList<>();

        // Obtén la lista de polígonos existentes
        List<PolygonBean> polygons = polygonService.list();

        // Implementa la lógica de intersección aquí
        for (PolygonBean polygon : polygons) {
            if (isSquareInsidePolygon(square, polygon)) {
                intersectedPolygonIds.add(polygon.getId().toString());
            }
        }

        return intersectedPolygonIds;
    }

    // Implementa la lógica específica para verificar si un cuadrado está dentro de un polígono
    private boolean isSquareInsidePolygon(Square square, PolygonBean polygon) {
        Integer[] xPoints = polygon.getXPoints();
        Integer[] yPoints = polygon.getYPoints();

        // Obtener las coordenadas del cuadrado
        Integer[] squareXPoints = square.getXPointsArray();
        Integer[] squareYPoints = square.getYPointsArray();

        // Utilizar el algoritmo de intersección de polígonos básico
        int i, j;
        boolean result = false;
        for (i = 0, j = xPoints.length - 1; i < xPoints.length; j = i++) {
            if ((yPoints[i] > squareYPoints[1]) != (yPoints[j] > squareYPoints[1]) &&
                (squareXPoints[0] < (xPoints[j] - xPoints[i]) * (squareYPoints[1] - yPoints[i]) / (yPoints[j] - yPoints[i]) + xPoints[i])) {
                result = !result;
            }
        }

        return result;
    }

    private String convertToFormattedArray(List<String> ids) {
        StringBuilder formattedArray = new StringBuilder("[");
        for (int i = 0; i < ids.size(); i++) {
            formattedArray.append("\"").append(ids.get(i)).append("\"");
            if (i < ids.size() - 1) {
                formattedArray.append(",");
            }
        }
        formattedArray.append("]");
        return formattedArray.toString();
    }

    @Override
    public Square getSquareById(int id) {
        // TODO: Implementar la lógica para obtener un cuadrado por ID desde el repositorio
        return null;
    }
    
    public Integer[] getXPointsArray() {
        return convertStringArrayToIntArray(this.getXPoints());
    }

    public Integer[] getYPointsArray() {
        return convertStringArrayToIntArray(this.getYPoints());
    }

    private Integer[] convertStringArrayToIntArray(String points) {
        String[] pointsArray = points.replaceAll("\\[|\\]", "").split(",");
        return Arrays.stream(pointsArray)
                     .map(Integer::parseInt)
                     .toArray(Integer[]::new);
    }
}
}
